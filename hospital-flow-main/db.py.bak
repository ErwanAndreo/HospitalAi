"""
Datenbankoperationen für HospitalFlow
SQLite-Datenbank mit ausschließlich aggregierten Daten (keine personenbezogenen Informationen)
"""
import sqlite3
import json
import os
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Optional
import random


class HospitalDB:
    def __init__(self, db_path: str = None):
        # Use environment variable if set, otherwise use default path
        if db_path is None:
            db_path = os.getenv("DB_PATH", "data/hospitalflow.db")
        # Create data directory if it doesn't exist
        db_dir = os.path.dirname(db_path)
        if db_dir and not os.path.exists(db_dir):
            os.makedirs(db_dir, exist_ok=True)
        self.db_path = db_path
        self.init_db()
    
    def get_connection(self, timeout: float = 10.0):
        """Get database connection with timeout to handle locks"""
        conn = sqlite3.connect(self.db_path, timeout=timeout)
        # Enable WAL mode for better concurrency (if not already enabled)
        conn.execute("PRAGMA journal_mode=WAL")
        return conn
    
    def init_db(self):
        """Initialisiere Datenbankschema"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        # Metriken-Tabelle (Live-Metriken)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS metrics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                metric_type TEXT NOT NULL,
                value REAL NOT NULL,
                unit TEXT,
                department TEXT
            )
        """)
        
        # Vorhersagen-Tabelle
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS predictions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                prediction_type TEXT NOT NULL,
                predicted_value REAL NOT NULL,
                confidence REAL,
                time_horizon_minutes INTEGER,
                department TEXT
            )
        """)
        
        # Warnungen-Tabelle
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS alerts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                alert_type TEXT NOT NULL,
                severity TEXT NOT NULL,
                message TEXT NOT NULL,
                department TEXT,
                acknowledged BOOLEAN DEFAULT 0,
                resolved BOOLEAN DEFAULT 0
            )
        """)
        
        # Empfehlungen-Tabelle
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS recommendations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                rec_type TEXT NOT NULL,
                title TEXT NOT NULL,
                description TEXT NOT NULL,
                priority TEXT NOT NULL,
                department TEXT,
                status TEXT DEFAULT 'pending',
                action_taken TEXT,
                action_timestamp DATETIME,
                action TEXT,
                reason TEXT,
                expected_impact TEXT,
                safety_note TEXT,
                explanation_score TEXT
            )
        """)
        
        # Migriere bestehende Empfehlungen-Tabelle, falls neue Spalten nicht existieren
        try:
            cursor.execute("ALTER TABLE recommendations ADD COLUMN action TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE recommendations ADD COLUMN reason TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE recommendations ADD COLUMN expected_impact TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE recommendations ADD COLUMN safety_note TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE recommendations ADD COLUMN explanation_score TEXT")
        except:
            pass
        
        # Prüfprotokoll
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS audit_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                action_type TEXT NOT NULL,
                user_role TEXT,
                entity_type TEXT,
                entity_id INTEGER,
                details TEXT,
                ip_address TEXT
            )
        """)
        
        # Transportanfragen
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS transport (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                request_type TEXT NOT NULL,
                from_location TEXT NOT NULL,
                to_location TEXT NOT NULL,
                priority TEXT NOT NULL,
                status TEXT DEFAULT 'pending',
                estimated_time_minutes INTEGER,
                actual_time_minutes INTEGER,
                related_entity_type TEXT,
                related_entity_id INTEGER,
                start_time DATETIME,
                expected_completion_time DATETIME,
                delay_minutes INTEGER
            )
        """)
        
        # Migriere bestehende transport Tabelle, falls neue Spalten nicht existieren
        try:
            cursor.execute("ALTER TABLE transport ADD COLUMN related_entity_type TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE transport ADD COLUMN related_entity_id INTEGER")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE transport ADD COLUMN start_time DATETIME")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE transport ADD COLUMN expected_completion_time DATETIME")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE transport ADD COLUMN delay_minutes INTEGER")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE transport ADD COLUMN planned_start_time DATETIME")
        except:
            pass
        
        # Inventar
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS inventory (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                item_name TEXT NOT NULL,
                category TEXT NOT NULL,
                current_stock INTEGER NOT NULL,
                min_threshold INTEGER NOT NULL,
                max_capacity INTEGER NOT NULL,
                department TEXT,
                unit TEXT
            )
        """)
        
        # Inventar-Verbrauchshistorie
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS inventory_consumption (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                item_id INTEGER NOT NULL,
                item_name TEXT NOT NULL,
                consumption_amount REAL NOT NULL,
                department TEXT,
                ed_load REAL,
                beds_occupied INTEGER,
                hospital_activity_factor REAL,
                FOREIGN KEY (item_id) REFERENCES inventory(id)
            )
        """)
        
        # Inventar-Bestellungen
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS inventory_orders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                item_id INTEGER NOT NULL,
                item_name TEXT NOT NULL,
                quantity INTEGER NOT NULL,
                department TEXT,
                status TEXT DEFAULT 'ordered',
                transport_id INTEGER,
                FOREIGN KEY (item_id) REFERENCES inventory(id),
                FOREIGN KEY (transport_id) REFERENCES transport(id)
            )
        """)
        
        # Gerätewartung
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS device_maintenance (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                device_id TEXT NOT NULL,
                device_type TEXT NOT NULL,
                department TEXT,
                urgency_level TEXT NOT NULL,
                last_maintenance DATE,
                next_maintenance_due DATE,
                usage_hours INTEGER,
                status TEXT DEFAULT 'operational'
            )
        """)
        
        # Migriere bestehende device_maintenance Tabelle von risk_level zu urgency_level
        try:
            # Check if risk_level column exists
            cursor.execute("PRAGMA table_info(device_maintenance)")
            columns = cursor.fetchall()
            column_names = [col[1] for col in columns]
            has_risk_level = 'risk_level' in column_names
            has_urgency_level = 'urgency_level' in column_names
            
            # Add urgency_level if it doesn't exist
            if not has_urgency_level:
                cursor.execute("ALTER TABLE device_maintenance ADD COLUMN urgency_level TEXT")
            
            # Migrate data from risk_level to urgency_level if risk_level exists
            if has_risk_level:
                cursor.execute("UPDATE device_maintenance SET urgency_level = risk_level WHERE urgency_level IS NULL OR urgency_level = ''")
                # Make risk_level nullable to avoid constraint issues (SQLite doesn't support DROP COLUMN easily)
                # Instead, we'll handle it in INSERT by including risk_level if it exists
                conn.commit()
        except Exception as e:
            pass
        
        # Entlassungsplanung (aggregiert)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS discharge_planning (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                department TEXT NOT NULL,
                ready_for_discharge_count INTEGER DEFAULT 0,
                pending_discharge_count INTEGER DEFAULT 0,
                avg_length_of_stay_hours REAL,
                discharge_capacity_utilization REAL
            )
        """)
        
        # Kapazitätsübersicht
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS capacity (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                department TEXT NOT NULL,
                total_beds INTEGER NOT NULL,
                occupied_beds INTEGER NOT NULL,
                available_beds INTEGER NOT NULL,
                utilization_rate REAL NOT NULL
            )
        """)
        
        # Migriere bestehende capacity Tabelle, falls neue Spalten nicht existieren
        try:
            cursor.execute("ALTER TABLE capacity ADD COLUMN total_rooms INTEGER")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE capacity ADD COLUMN available_rooms INTEGER")
        except:
            pass
        
        # Operationen-Tabelle
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS operations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                operation_type TEXT NOT NULL,
                department TEXT NOT NULL,
                status TEXT NOT NULL,
                duration_minutes INTEGER,
                start_time DATETIME,
                end_time DATETIME,
                planned_start_time DATETIME
            )
        """)
        
        # Personal-Tabelle
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS staff (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                category TEXT NOT NULL,
                role TEXT NOT NULL,
                department TEXT,
                contact TEXT,
                contract_hours_per_week REAL NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Dienstplan-Einträge
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS schedule_entries (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                staff_id INTEGER NOT NULL,
                week_start_date DATE NOT NULL,
                day_of_week INTEGER NOT NULL,
                planned_hours REAL NOT NULL,
                shift_start TIME,
                shift_end TIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (staff_id) REFERENCES staff(id)
            )
        """)
        
        # Tatsächliche Arbeitsstunden
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS actual_hours (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                staff_id INTEGER NOT NULL,
                date DATE NOT NULL,
                actual_hours REAL NOT NULL,
                notes TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (staff_id) REFERENCES staff(id)
            )
        """)
        
        conn.commit()
        conn.close()
        
        # Small delay to ensure connection is fully released before seeding
        import time
        time.sleep(0.2)
        
        self.seed_sample_data()
    
    def seed_sample_data(self):
        """Fülle Datenbank mit Daten des Waldkrankenhauses Erlangen"""
        # Add small delay to ensure previous connection is fully closed
        import time
        time.sleep(0.1)
        
        conn = self.get_connection(timeout=30.0)  # Longer timeout for seed operation
        cursor = conn.cursor()
        
        # Lösche bestehende Daten (in korrekter Reihenfolge)
        try:
            cursor.execute("DELETE FROM actual_hours")
            cursor.execute("DELETE FROM schedule_entries")
            cursor.execute("DELETE FROM staff")
            cursor.execute("DELETE FROM metrics")
            cursor.execute("DELETE FROM predictions")
            cursor.execute("DELETE FROM alerts")
            cursor.execute("DELETE FROM recommendations")
            cursor.execute("DELETE FROM transport")
            cursor.execute("DELETE FROM inventory")
            cursor.execute("DELETE FROM device_maintenance")
            cursor.execute("DELETE FROM discharge_planning")
            cursor.execute("DELETE FROM capacity")
            cursor.execute("DELETE FROM operations")
            cursor.execute("DELETE FROM audit_log")
            conn.commit()  # Commit deletes before inserts
        except sqlite3.OperationalError as e:
            conn.rollback()
            conn.close()
            raise
        
        # Abteilungen des Waldkrankenhauses Erlangen (290 Betten insgesamt)
        departments = [
            "Kardiologie",
            "Gastroenterologie",
            "Akutgeriatrie",
            "Chirurgie",
            "Intensivstation",
            "Orthopädie",
            "Urologie",
            "Wirbelsäule",
            "HNO"
        ]
        
        # Bettenverteilung auf 9 Abteilungen (Summe = 290)
        beds_distribution = {
            "Kardiologie": 45,
            "Gastroenterologie": 40,
            "Akutgeriatrie": 35,
            "Chirurgie": 45,
            "Intensivstation": 18,
            "Orthopädie": 45,
            "Urologie": 25,
            "Wirbelsäule": 25,
            "HNO": 12
        }
        
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        
        # Metriken einfügen
        for i in range(20):
            metric_type = random.choice(["patient_count", "wait_time", "throughput", "occupancy"])
            # Assign proper units based on metric type
            if metric_type == "wait_time":
                unit = "minutes"
                value = random.uniform(5, 30)
            elif metric_type == "throughput":
                unit = "per_hour"
                value = random.uniform(10, 50)
            elif metric_type == "patient_count":
                unit = "count"
                value = random.uniform(5, 50)
            else:  # occupancy
                unit = "percent"
                value = random.uniform(50, 95)
            
            cursor.execute("""
                INSERT INTO metrics (timestamp, metric_type, value, unit, department)
                VALUES (?, ?, ?, ?, ?)
            """, (
                now - timedelta(minutes=random.randint(0, 60)),
                metric_type,
                value,
                unit,
                random.choice(departments)
            ))
        
        # Vorhersagen einfügen
        # Generiere patient_arrival und bed_demand Vorhersagen für alle Abteilungen
        # Diese werden später durch update_predictions() mit realistischen Daten ersetzt
        # Hier werden initiale Demo-Daten generiert
        from utils import calculate_prediction_confidence
        
        for dept in departments:
            # Generiere Vorhersagen für 5, 10, 15 Minuten Zeithorizont
            for time_horizon in [5, 10, 15]:
                # Patientenzugang-Vorhersage (Demo-Daten)
                # Realistische Werte: 0-8 Patienten je nach Abteilung
                if dept == "Intensivstation":
                    patient_arrival = random.uniform(0, 2)  # Weniger Ankünfte direkt
                elif dept == "Chirurgie":
                    patient_arrival = random.uniform(1, 4)
                elif dept == "Notaufnahme" or dept == "ER":
                    patient_arrival = random.uniform(2, 6)  # Mehr Ankünfte
                else:
                    patient_arrival = random.uniform(0, 3)
                
                confidence = calculate_prediction_confidence(patient_arrival, time_horizon)
                
                cursor.execute("""
                    INSERT INTO predictions (timestamp, prediction_type, predicted_value, confidence, time_horizon_minutes, department)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (
                    now,
                    'patient_arrival',
                    round(patient_arrival),
                    confidence,
                    time_horizon,
                    dept
                ))
                
                # Bettenbedarf-Vorhersage (Demo-Daten)
                # Hole aktuelle Auslastung aus capacity (falls bereits vorhanden)
                cursor.execute("SELECT utilization_rate FROM capacity WHERE department = ? ORDER BY timestamp DESC LIMIT 1", (dept,))
                capacity_row = cursor.fetchone()
                if capacity_row:
                    current_utilization = capacity_row[0] * 100  # Konvertiere zu Prozent
                else:
                    # Fallback: Realistische Auslastung je nach Abteilung
                    if dept == "Intensivstation":
                        current_utilization = random.uniform(85, 95)
                    elif dept in ["Chirurgie", "Kardiologie"]:
                        current_utilization = random.uniform(75, 90)
                    else:
                        current_utilization = random.uniform(65, 85)
                
                # Erwartete Auslastung mit leichter Variation
                predicted_utilization = current_utilization + random.uniform(-3, 5)
                predicted_utilization = max(0, min(100, predicted_utilization))
                
                bed_confidence = calculate_prediction_confidence(predicted_utilization, time_horizon)
                
                cursor.execute("""
                    INSERT INTO predictions (timestamp, prediction_type, predicted_value, confidence, time_horizon_minutes, department)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (
                    now,
                    'bed_demand',
                    round(predicted_utilization, 1),
                    bed_confidence,
                    time_horizon,
                    dept
                ))
        
        # Warnungen werden jetzt dynamisch durch generate_alerts() generiert
        # Hardcodierte Test-Alerts wurden entfernt, da der Algorithmus die Warnungen
        # basierend auf aktuellen Daten aus allen Tabs automatisch erstellt
        
        # Empfehlungen mit neuem Template-Format einfügen
        recs_data = [
            (
                "capacity", 
                "Erwägen Sie das Öffnen von Überlaufbetten",
                "Intensivstation-Auslastung hoch. Öffnen Sie 2 Überlaufbetten.",
                "hoch",
                "Intensivstation",
                "Öffnen Sie vorübergehend 2 Überlaufbetten im Intensivbereich.",
                "Intensivstation-Kapazität bei 94% mit steigendem Trend. Aktuelle Belegung: 17/18 Betten.",
                "Wartezeiten um 15-20 Minuten reduzieren. Kapazitätsüberlauf in den nächsten 30 Minuten verhindern.",
                "Überprüfen Sie die Ausrüstungsbereitschaft der Überlaufbetten. Bestätigen Sie die Verfügbarkeit des Personals für zusätzliche Betten.",
                "hoch"
            ),
            (
                "staffing",
                "Pflegekraft in die Chirurgie umsetzen",
                "Chirurgie-Belastung steigt. Versetzen Sie 1 Pflegekraft von der Urologie.",
                "mittel",
                "Chirurgie",
                "Versetzen Sie vorübergehend 1 Mitarbeiter von der Urologie für 30 Minuten in die Chirurgie.",
                "Chirurgie-Belastung steigt + Operationsplan nimmt zu. Aktuelle Auslastung: 42/45 Betten.",
                "Voraussichtliche Entlastung in 15 Minuten. Operationsablauf optimieren.",
                "Menschliche Kontrolle: Verfügbarkeit vor Umsetzung prüfen. Urologie Abdeckung sicherstellen.",
                "mittel"
            ),
            (
                "inventory",
                "Zusätzliche Vorräte bestellen",
                "Sauerstoffflaschenbestand bei 18%. Bestellen Sie 25 Einheiten.",
                "hoch",
                "Intensivstation",
                "Bestellen Sie sofort 25 Sauerstoffflaschen für die Intensivstation.",
                "Sauerstoffflaschenbestand bei 18% (9/50 Einheiten). Verbrauchsrate zeigt Engpassrisiko in 4-6 Stunden.",
                "Versorgungsengpass verhindern. Kontinuierliche Patientenversorgung sicherstellen.",
                "Lieferantenverfügbarkeit und Lieferzeit prüfen. Notfall-Lieferanten ggf. berücksichtigen.",
                "hoch"
            ),
        ]
        for rec in recs_data:
            rec_type, title, description, priority, department, action, reason, expected_impact, safety_note, explanation_score = rec
            cursor.execute("""
                INSERT INTO recommendations (timestamp, rec_type, title, description, priority, department, status, action, reason, expected_impact, safety_note, explanation_score)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (now - timedelta(minutes=random.randint(10, 180)), rec_type, title, description, priority, department, "pending", action, reason, expected_impact, safety_note, explanation_score))
        
        # Inventar einfügen - Erweiterte Materialdatenbank mit realistischen Materialien
        inventory_items = [
            # OP-Materialien (Chirurgie, Orthopädie, Urologie, HNO)
            ("OP-Masken", "PSA", 120, 50, 500, "Chirurgie", "Boxen"),
            ("OP-Handschuhe", "PSA", 200, 100, 1000, "Chirurgie", "Paare"),
            ("OP-Tücher", "OP-Bedarf", 80, 40, 300, "Chirurgie", "Pakete"),
            ("OP-Kittel", "OP-Bedarf", 45, 30, 200, "Chirurgie", "Stück"),
            ("Sterile Kompressen", "Verbandsmaterial", 150, 80, 500, "Chirurgie", "Pakete"),
            ("Wundverbände", "Verbandsmaterial", 180, 100, 600, "Chirurgie", "Stück"),
            ("Nahtmaterial", "OP-Bedarf", 60, 30, 250, "Chirurgie", "Sets"),
            ("OP-Handschuhe", "PSA", 150, 80, 600, "Orthopädie", "Paare"),
            ("Gipsbinden", "Orthopädie", 80, 40, 300, "Orthopädie", "Rollen"),
            ("Schienen", "Orthopädie", 25, 15, 100, "Orthopädie", "Stück"),
            ("OP-Handschuhe", "PSA", 100, 50, 400, "Urologie", "Paare"),
            ("Katheter", "Medizinprodukte", 45, 25, 200, "Urologie", "Stück"),
            ("OP-Masken", "PSA", 60, 30, 200, "HNO", "Boxen"),
            ("OP-Handschuhe", "PSA", 50, 25, 200, "HNO", "Paare"),
            
            # Verbrauchsmaterialien (alle Abteilungen)
            ("Infusionslösungen", "Versorgung", 200, 100, 800, "Intensivstation", "Einheiten"),
            ("Infusionslösungen", "Versorgung", 120, 60, 400, "Kardiologie", "Einheiten"),
            ("Spritzen", "Einwegprodukte", 300, 150, 1000, "Intensivstation", "Stück"),
            ("Spritzen", "Einwegprodukte", 200, 100, 600, "Kardiologie", "Stück"),
            ("Kanülen", "Einwegprodukte", 250, 120, 800, "Intensivstation", "Stück"),
            ("Einmalhandschuhe", "PSA", 500, 250, 2000, "Intensivstation", "Paare"),
            ("Einmalhandschuhe", "PSA", 400, 200, 1500, "Kardiologie", "Paare"),
            ("Einmalhandschuhe", "PSA", 350, 180, 1200, "Gastroenterologie", "Paare"),
            ("Desinfektionsmittel", "Hygiene", 80, 40, 300, "Intensivstation", "Liter"),
            ("Desinfektionsmittel", "Hygiene", 60, 30, 200, "Chirurgie", "Liter"),
            ("Wundverbände", "Verbandsmaterial", 100, 50, 400, "Gastroenterologie", "Stück"),
            ("Sterile Kompressen", "Verbandsmaterial", 80, 40, 300, "Akutgeriatrie", "Pakete"),
            
            # Spezialmaterialien
            ("Sauerstoffflaschen", "Medizinische Gase", 25, 20, 120, "Notaufnahme", "Einheiten"),
            ("Sauerstoffflaschen", "Medizinische Gase", 30, 25, 150, "Intensivstation", "Einheiten"),
            ("Beatmungsfilter", "Ausrüstung", 15, 10, 60, "Intensivstation", "Einheiten"),
            ("Drainagen", "Medizinprodukte", 40, 20, 150, "Chirurgie", "Stück"),
            ("Katheter", "Medizinprodukte", 35, 20, 150, "Intensivstation", "Stück"),
            ("Katheter", "Medizinprodukte", 30, 15, 120, "Gastroenterologie", "Stück"),
            ("Wundverbände", "Verbandsmaterial", 90, 50, 350, "Wirbelsäule", "Stück"),
            ("OP-Handschuhe", "PSA", 80, 40, 300, "Wirbelsäule", "Paare"),
        ]
        for item in inventory_items:
            cursor.execute("""
                INSERT INTO inventory (timestamp, item_name, category, current_stock, min_threshold, max_capacity, department, unit)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (now, *item))
        
        # Gerätewartung einfügen - Realistische Geräte pro Abteilung
        from datetime import date
        today = date.today()
        
        devices = [
            # Intensivstation (4-5 Beatmungsgeräte, 8-10 Monitore, 2 Defibrillatoren)
            ("V-201", "Beatmungsgerät", "Intensivstation", "hoch", str(today - timedelta(days=45)), str(today + timedelta(days=20)), 3800, "in_betrieb"),
            ("V-202", "Beatmungsgerät", "Intensivstation", "hoch", str(today - timedelta(days=30)), str(today + timedelta(days=35)), 3200, "in_betrieb"),
            ("V-203", "Beatmungsgerät", "Intensivstation", "hoch", str(today - timedelta(days=60)), str(today + timedelta(days=5)), 4200, "in_betrieb"),
            ("V-204", "Beatmungsgerät", "Intensivstation", "hoch", str(today - timedelta(days=25)), str(today + timedelta(days=40)), 2900, "in_betrieb"),
            ("V-205", "Beatmungsgerät", "Intensivstation", "hoch", str(today - timedelta(days=50)), str(today + timedelta(days=15)), 3600, "in_betrieb"),
            ("M-301", "Monitor", "Intensivstation", "mittel", str(today - timedelta(days=90)), str(today + timedelta(days=90)), 5200, "in_betrieb"),
            ("M-302", "Monitor", "Intensivstation", "mittel", str(today - timedelta(days=85)), str(today + timedelta(days=95)), 5100, "in_betrieb"),
            ("M-303", "Monitor", "Intensivstation", "mittel", str(today - timedelta(days=80)), str(today + timedelta(days=100)), 4900, "in_betrieb"),
            ("M-304", "Monitor", "Intensivstation", "mittel", str(today - timedelta(days=75)), str(today + timedelta(days=105)), 4800, "in_betrieb"),
            ("M-305", "Monitor", "Intensivstation", "niedrig", str(today - timedelta(days=70)), str(today + timedelta(days=110)), 4600, "in_betrieb"),
            ("D-101", "Defibrillator", "Intensivstation", "niedrig", str(today - timedelta(days=120)), str(today + timedelta(days=240)), 1800, "in_betrieb"),
            ("D-102", "Defibrillator", "Intensivstation", "niedrig", str(today - timedelta(days=110)), str(today + timedelta(days=250)), 1700, "in_betrieb"),
            # Kardiologie (3-4 EKG, 2 Defibrillatoren, 5-6 Monitore)
            ("EKG-401", "EKG-Gerät", "Kardiologie", "mittel", str(today - timedelta(days=100)), str(today + timedelta(days=80)), 2100, "in_betrieb"),
            ("EKG-402", "EKG-Gerät", "Kardiologie", "mittel", str(today - timedelta(days=95)), str(today + timedelta(days=85)), 2000, "in_betrieb"),
            ("EKG-403", "EKG-Gerät", "Kardiologie", "niedrig", str(today - timedelta(days=90)), str(today + timedelta(days=90)), 1900, "in_betrieb"),
            ("D-201", "Defibrillator", "Kardiologie", "niedrig", str(today - timedelta(days=130)), str(today + timedelta(days=230)), 1600, "in_betrieb"),
            ("D-202", "Defibrillator", "Kardiologie", "niedrig", str(today - timedelta(days=125)), str(today + timedelta(days=235)), 1550, "in_betrieb"),
            ("M-501", "Monitor", "Kardiologie", "mittel", str(today - timedelta(days=100)), str(today + timedelta(days=80)), 2400, "in_betrieb"),
            ("M-502", "Monitor", "Kardiologie", "mittel", str(today - timedelta(days=95)), str(today + timedelta(days=85)), 2300, "in_betrieb"),
            ("M-503", "Monitor", "Kardiologie", "niedrig", str(today - timedelta(days=90)), str(today + timedelta(days=90)), 2200, "in_betrieb"),
            # Chirurgie (2-3 OP-Monitore, 1-2 Defibrillatoren)
            ("OP-601", "OP-Monitor", "Chirurgie", "hoch", str(today - timedelta(days=60)), str(today + timedelta(days=30)), 2800, "in_betrieb"),
            ("OP-602", "OP-Monitor", "Chirurgie", "hoch", str(today - timedelta(days=55)), str(today + timedelta(days=35)), 2700, "in_betrieb"),
            ("OP-603", "OP-Monitor", "Chirurgie", "mittel", str(today - timedelta(days=50)), str(today + timedelta(days=40)), 2600, "in_betrieb"),
            ("D-301", "Defibrillator", "Chirurgie", "niedrig", str(today - timedelta(days=140)), str(today + timedelta(days=220)), 1500, "in_betrieb"),
            # Radiologie (1 CT, 1 MRT, 2-3 Röntgen, 2-3 Ultraschall)
            ("CT-701", "CT-Gerät", None, "hoch", str(today - timedelta(days=180)), str(today + timedelta(days=180)), 4200, "in_betrieb"),
            ("MRT-801", "MRT-Gerät", None, "hoch", str(today - timedelta(days=200)), str(today + timedelta(days=160)), 4800, "in_betrieb"),
            ("RÖ-901", "Röntgengerät", None, "mittel", str(today - timedelta(days=120)), str(today + timedelta(days=60)), 3100, "in_betrieb"),
            ("RÖ-902", "Röntgengerät", None, "mittel", str(today - timedelta(days=115)), str(today + timedelta(days=65)), 3000, "in_betrieb"),
            ("US-1001", "Ultraschallgerät", None, "niedrig", str(today - timedelta(days=100)), str(today + timedelta(days=80)), 2100, "in_betrieb"),
            ("US-1002", "Ultraschallgerät", None, "niedrig", str(today - timedelta(days=95)), str(today + timedelta(days=85)), 2000, "in_betrieb"),
            # Weitere Abteilungen (Basis-Monitore)
            ("M-1101", "Monitor", "Orthopädie", "niedrig", str(today - timedelta(days=110)), str(today + timedelta(days=70)), 2500, "in_betrieb"),
            ("M-1102", "Monitor", "Urologie", "niedrig", str(today - timedelta(days=105)), str(today + timedelta(days=75)), 2400, "in_betrieb"),
            ("M-1103", "Monitor", "Gastroenterologie", "niedrig", str(today - timedelta(days=100)), str(today + timedelta(days=80)), 2300, "in_betrieb"),
            ("M-1104", "Monitor", "Akutgeriatrie", "niedrig", str(today - timedelta(days=95)), str(today + timedelta(days=85)), 2200, "in_betrieb"),
        ]
        
        # Importiere Dringlichkeitsberechnung
        from utils import calculate_device_urgency, get_max_usage_hours
        
        # Check if risk_level column exists (once, not per device)
        cursor.execute("PRAGMA table_info(device_maintenance)")
        columns = cursor.fetchall()
        column_names = [col[1] for col in columns]
        has_risk_level = 'risk_level' in column_names
        
        
        for device in devices:
            device_id, device_type, department, _, last_maintenance, next_maintenance_due, usage_hours, status = device
            
            # Berechne Tage bis zur Wartung
            days_until_maintenance = (datetime.strptime(next_maintenance_due, '%Y-%m-%d').date() - today).days
            
            # Hole maximale Betriebsstunden für diesen Gerätetyp
            max_usage_hours = get_max_usage_hours(device_type)
            
            # Berechne Dringlichkeit
            urgency_level = calculate_device_urgency(days_until_maintenance, usage_hours, max_usage_hours)
            
            if has_risk_level:
                # Include risk_level with same value as urgency_level for backward compatibility
                cursor.execute("""
                    INSERT INTO device_maintenance (timestamp, device_id, device_type, department, urgency_level, risk_level, last_maintenance, next_maintenance_due, usage_hours, status)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (now, device_id, device_type, department, urgency_level, urgency_level, last_maintenance, next_maintenance_due, usage_hours, status))
            else:
                cursor.execute("""
                    INSERT INTO device_maintenance (timestamp, device_id, device_type, department, urgency_level, last_maintenance, next_maintenance_due, usage_hours, status)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (now, device_id, device_type, department, urgency_level, last_maintenance, next_maintenance_due, usage_hours, status))
        
        # Entlassungsplanung einfügen - Realistische Werte pro Abteilung
        discharge_data = {
            "Kardiologie": (random.randint(2, 5), random.randint(3, 7), random.uniform(72, 96), random.uniform(0.6, 0.8)),
            "Gastroenterologie": (random.randint(1, 4), random.randint(2, 6), random.uniform(48, 96), random.uniform(0.5, 0.75)),
            "Akutgeriatrie": (random.randint(1, 3), random.randint(4, 8), random.uniform(120, 240), random.uniform(0.7, 0.9)),
            "Chirurgie": (random.randint(3, 6), random.randint(4, 8), random.uniform(72, 120), random.uniform(0.65, 0.85)),
            "Intensivstation": (random.randint(0, 2), random.randint(1, 3), random.uniform(48, 168), random.uniform(0.8, 0.95)),
            "Orthopädie": (random.randint(2, 5), random.randint(3, 7), random.uniform(96, 168), random.uniform(0.6, 0.8)),
            "Urologie": (random.randint(1, 3), random.randint(2, 5), random.uniform(48, 96), random.uniform(0.55, 0.75)),
            "Wirbelsäule": (random.randint(1, 3), random.randint(2, 5), random.uniform(120, 192), random.uniform(0.6, 0.8)),
            "HNO": (random.randint(0, 2), random.randint(1, 3), random.uniform(24, 48), random.uniform(0.5, 0.7)),
        }
        
        for dept in departments:
            ready, pending, avg_stay, utilization = discharge_data[dept]
            cursor.execute("""
                INSERT INTO discharge_planning (timestamp, department, ready_for_discharge_count, pending_discharge_count, avg_length_of_stay_hours, discharge_capacity_utilization)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (now, dept, ready, pending, avg_stay, utilization))
        
        # Kapazität einfügen - Realistische Bettenverteilung (290 Betten total)
        for dept in departments:
            total = beds_distribution[dept]
            # Realistische Belegung (70-90% je nach Abteilung)
            if dept == "Intensivstation":
                occupied = random.randint(14, 17)  # 78-94% Auslastung
            elif dept in ["Chirurgie", "Kardiologie"]:
                occupied = random.randint(int(total * 0.75), int(total * 0.90))
            else:
                occupied = random.randint(int(total * 0.70), int(total * 0.85))
            available = total - occupied
            # Räume: 1-2 Betten pro Zimmer, also etwa 60-70% der Bettenanzahl als Räume
            total_rooms = max(5, int(total * 0.65))
            available_rooms = max(0, int(available * 0.65))
            utilization_rate = occupied / total if total > 0 else 0.0
            cursor.execute("""
                INSERT INTO capacity (timestamp, department, total_beds, occupied_beds, available_beds, utilization_rate, total_rooms, available_rooms)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (now, dept, total, occupied, available, utilization_rate, total_rooms, available_rooms))
        
        # Personal einfügen - Realistische Mitarbeiterzahl für Waldkrankenhaus Erlangen (290 Betten)
        # Repräsentative Stichprobe basierend auf ~1000 Mitarbeiter (137 Ärzte, 354 Pflegekräfte)
        staff_data = [
            # Kardiologie (45 Betten) - ~8 Pflegekräfte, ~3 Ärzte
            ("Anna Becker", "Pflegekräfte", "Stationsschwester", "Kardiologie", "anna.becker@waldkrankenhaus.de", 40.0),
            ("Clara Fischer", "Pflegekräfte", "Pflegekraft", "Kardiologie", "clara.fischer@waldkrankenhaus.de", 35.0),
            ("Emma Hoffmann", "Pflegekräfte", "Pflegekraft", "Kardiologie", "emma.hoffmann@waldkrankenhaus.de", 40.0),
            ("Lisa Klein", "Pflegekräfte", "Pflegekraft", "Kardiologie", "lisa.klein@waldkrankenhaus.de", 38.0),
            ("Maria Müller", "Pflegekräfte", "Pflegekraft", "Kardiologie", "maria.mueller@waldkrankenhaus.de", 35.0),
            ("Sophie Neumann", "Pflegekräfte", "Pflegekraft", "Kardiologie", "sophie.neumann@waldkrankenhaus.de", 40.0),
            ("Petra Adler", "Pflegekräfte", "Pflegekraft", "Kardiologie", "petra.adler@waldkrankenhaus.de", 35.0),
            ("Tanja Zimmermann", "Pflegekräfte", "Pflegekraft", "Kardiologie", "tanja.zimmermann@waldkrankenhaus.de", 38.0),
            ("Dr. Andreas Bauer", "Ärzte", "Chefarzt", "Kardiologie", "andreas.bauer@waldkrankenhaus.de", 55.0),
            ("Dr. Benjamin Koch", "Ärzte", "Oberarzt", "Kardiologie", "benjamin.koch@waldkrankenhaus.de", 50.0),
            ("Dr. Christian Lange", "Ärzte", "Facharzt", "Kardiologie", "christian.lange@waldkrankenhaus.de", 45.0),
            
            # Gastroenterologie (40 Betten) - ~7 Pflegekräfte, ~2 Ärzte
            ("Sabine Bergmann", "Pflegekräfte", "Stationsschwester", "Gastroenterologie", "sabine.bergmann@waldkrankenhaus.de", 40.0),
            ("Julia Hoffmann", "Pflegekräfte", "Pflegekraft", "Gastroenterologie", "julia.hoffmann@waldkrankenhaus.de", 35.0),
            ("Katharina Schmidt", "Pflegekräfte", "Pflegekraft", "Gastroenterologie", "katharina.schmidt@waldkrankenhaus.de", 40.0),
            ("Laura Wagner", "Pflegekräfte", "Pflegekraft", "Gastroenterologie", "laura.wagner@waldkrankenhaus.de", 38.0),
            ("Nicole Becker", "Pflegekräfte", "Pflegekraft", "Gastroenterologie", "nicole.becker@waldkrankenhaus.de", 35.0),
            ("Sandra Fischer", "Pflegekräfte", "Pflegekraft", "Gastroenterologie", "sandra.fischer@waldkrankenhaus.de", 40.0),
            ("Yvonne Klein", "Pflegekräfte", "Pflegekraft", "Gastroenterologie", "yvonne.klein@waldkrankenhaus.de", 38.0),
            ("Dr. Felix Schneider", "Ärzte", "Chefarzt", "Gastroenterologie", "felix.schneider@waldkrankenhaus.de", 55.0),
            ("Dr. Gregor Müller", "Ärzte", "Oberarzt", "Gastroenterologie", "gregor.mueller@waldkrankenhaus.de", 50.0),
            
            # Akutgeriatrie (35 Betten) - ~6 Pflegekräfte, ~2 Ärzte
            ("Andrea Meier", "Pflegekräfte", "Stationsschwester", "Akutgeriatrie", "andrea.meier@waldkrankenhaus.de", 40.0),
            ("Brigitte Neumann", "Pflegekräfte", "Pflegekraft", "Akutgeriatrie", "brigitte.neumann@waldkrankenhaus.de", 35.0),
            ("Christina Bauer", "Pflegekräfte", "Pflegekraft", "Akutgeriatrie", "christina.bauer@waldkrankenhaus.de", 40.0),
            ("Doris Koch", "Pflegekräfte", "Pflegekraft", "Akutgeriatrie", "doris.koch@waldkrankenhaus.de", 38.0),
            ("Elke Richter", "Pflegekräfte", "Pflegekraft", "Akutgeriatrie", "elke.richter@waldkrankenhaus.de", 35.0),
            ("Franziska Weber", "Pflegekräfte", "Pflegekraft", "Akutgeriatrie", "franziska.weber@waldkrankenhaus.de", 40.0),
            ("Dr. Helmut Schmidt", "Ärzte", "Chefarzt", "Akutgeriatrie", "helmut.schmidt@waldkrankenhaus.de", 55.0),
            ("Dr. Ingrid Wagner", "Ärzte", "Oberärztin", "Akutgeriatrie", "ingrid.wagner@waldkrankenhaus.de", 50.0),
            
            # Chirurgie (45 Betten) - ~8 Pflegekräfte, ~4 Ärzte
            ("Gabriele Hoffmann", "Pflegekräfte", "Stationsschwester", "Chirurgie", "gabriele.hoffmann@waldkrankenhaus.de", 40.0),
            ("Hannah Becker", "Pflegekräfte", "Pflegekraft", "Chirurgie", "hannah.becker@waldkrankenhaus.de", 35.0),
            ("Iris Fischer", "Pflegekräfte", "Pflegekraft", "Chirurgie", "iris.fischer@waldkrankenhaus.de", 40.0),
            ("Jessica Klein", "Pflegekräfte", "Pflegekraft", "Chirurgie", "jessica.klein@waldkrankenhaus.de", 38.0),
            ("Katrin Müller", "Pflegekräfte", "Pflegekraft", "Chirurgie", "katrin.mueller@waldkrankenhaus.de", 35.0),
            ("Lisa Neumann", "Pflegekräfte", "Pflegekraft", "Chirurgie", "lisa.neumann@waldkrankenhaus.de", 40.0),
            ("Melanie Bauer", "Pflegekräfte", "Pflegekraft", "Chirurgie", "melanie.bauer@waldkrankenhaus.de", 38.0),
            ("Nadine Koch", "Pflegekräfte", "Pflegekraft", "Chirurgie", "nadine.koch@waldkrankenhaus.de", 35.0),
            ("Dr. Oliver Richter", "Ärzte", "Chefarzt", "Chirurgie", "oliver.richter@waldkrankenhaus.de", 55.0),
            ("Dr. Peter Weber", "Ärzte", "Oberarzt", "Chirurgie", "peter.weber@waldkrankenhaus.de", 50.0),
            ("Dr. Rainer Schmidt", "Ärzte", "Facharzt", "Chirurgie", "rainer.schmidt@waldkrankenhaus.de", 45.0),
            ("Dr. Stefan Wagner", "Ärzte", "Assistenzarzt", "Chirurgie", "stefan.wagner@waldkrankenhaus.de", 40.0),
            
            # Intensivstation (18 Betten) - ~12 Pflegekräfte (höherer Personalschlüssel), ~3 Ärzte
            ("Monika Hoffmann", "Pflegekräfte", "Stationsschwester", "Intensivstation", "monika.hoffmann@waldkrankenhaus.de", 40.0),
            ("Nina Becker", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "nina.becker@waldkrankenhaus.de", 35.0),
            ("Olga Fischer", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "olga.fischer@waldkrankenhaus.de", 40.0),
            ("Patricia Klein", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "patricia.klein@waldkrankenhaus.de", 38.0),
            ("Renate Müller", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "renate.mueller@waldkrankenhaus.de", 35.0),
            ("Sandra Neumann", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "sandra.neumann@waldkrankenhaus.de", 40.0),
            ("Susanne Bauer", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "susanne.bauer@waldkrankenhaus.de", 38.0),
            ("Ute Koch", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "ute.koch@waldkrankenhaus.de", 35.0),
            ("Vera Richter", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "vera.richter@waldkrankenhaus.de", 40.0),
            ("Waltraud Weber", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "waltraud.weber@waldkrankenhaus.de", 38.0),
            ("Xenia Schmidt", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "xenia.schmidt@waldkrankenhaus.de", 35.0),
            ("Yasmin Wagner", "Pflegekräfte", "Intensivpflegerin", "Intensivstation", "yasmin.wagner@waldkrankenhaus.de", 40.0),
            ("Dr. Thomas Adler", "Ärzte", "Chefarzt", "Intensivstation", "thomas.adler@waldkrankenhaus.de", 55.0),
            ("Dr. Ulrich Berg", "Ärzte", "Oberarzt", "Intensivstation", "ulrich.berg@waldkrankenhaus.de", 50.0),
            ("Dr. Volker Dorn", "Ärzte", "Facharzt", "Intensivstation", "volker.dorn@waldkrankenhaus.de", 45.0),
            
            # Orthopädie (45 Betten) - ~8 Pflegekräfte, ~3 Ärzte
            ("Birgit Hoffmann", "Pflegekräfte", "Stationsschwester", "Orthopädie", "birgit.hoffmann@waldkrankenhaus.de", 40.0),
            ("Corinna Becker", "Pflegekräfte", "Pflegekraft", "Orthopädie", "corinna.becker@waldkrankenhaus.de", 35.0),
            ("Daniela Fischer", "Pflegekräfte", "Pflegekraft", "Orthopädie", "daniela.fischer@waldkrankenhaus.de", 40.0),
            ("Eva Klein", "Pflegekräfte", "Pflegekraft", "Orthopädie", "eva.klein@waldkrankenhaus.de", 38.0),
            ("Friederike Müller", "Pflegekräfte", "Pflegekraft", "Orthopädie", "friederike.mueller@waldkrankenhaus.de", 35.0),
            ("Gudrun Neumann", "Pflegekräfte", "Pflegekraft", "Orthopädie", "gudrun.neumann@waldkrankenhaus.de", 40.0),
            ("Heike Bauer", "Pflegekräfte", "Pflegekraft", "Orthopädie", "heike.bauer@waldkrankenhaus.de", 38.0),
            ("Ines Koch", "Pflegekräfte", "Pflegekraft", "Orthopädie", "ines.koch@waldkrankenhaus.de", 35.0),
            ("Dr. Wolfgang Eckert", "Ärzte", "Chefarzt", "Orthopädie", "wolfgang.eckert@waldkrankenhaus.de", 55.0),
            ("Dr. Alexander Frank", "Ärzte", "Oberarzt", "Orthopädie", "alexander.frank@waldkrankenhaus.de", 50.0),
            ("Dr. Bernd Gross", "Ärzte", "Facharzt", "Orthopädie", "bernd.gross@waldkrankenhaus.de", 45.0),
            
            # Urologie (25 Betten) - ~5 Pflegekräfte, ~2 Ärzte
            ("Jasmin Richter", "Pflegekräfte", "Stationsschwester", "Urologie", "jasmin.richter@waldkrankenhaus.de", 40.0),
            ("Kerstin Weber", "Pflegekräfte", "Pflegekraft", "Urologie", "kerstin.weber@waldkrankenhaus.de", 35.0),
            ("Lena Schmidt", "Pflegekräfte", "Pflegekraft", "Urologie", "lena.schmidt@waldkrankenhaus.de", 40.0),
            ("Marion Wagner", "Pflegekräfte", "Pflegekraft", "Urologie", "marion.wagner@waldkrankenhaus.de", 38.0),
            ("Natalie Hoffmann", "Pflegekräfte", "Pflegekraft", "Urologie", "natalie.hoffmann@waldkrankenhaus.de", 35.0),
            ("Dr. Georg Weber", "Ärzte", "Chefarzt", "Urologie", "georg.weber@waldkrankenhaus.de", 55.0),
            ("Dr. Harald Zimmermann", "Ärzte", "Oberarzt", "Urologie", "harald.zimmermann@waldkrankenhaus.de", 50.0),
            
            # Wirbelsäule (25 Betten) - ~5 Pflegekräfte, ~2 Ärzte
            ("Olga Becker", "Pflegekräfte", "Stationsschwester", "Wirbelsäule", "olga.becker@waldkrankenhaus.de", 40.0),
            ("Pia Fischer", "Pflegekräfte", "Pflegekraft", "Wirbelsäule", "pia.fischer@waldkrankenhaus.de", 35.0),
            ("Rita Klein", "Pflegekräfte", "Pflegekraft", "Wirbelsäule", "rita.klein@waldkrankenhaus.de", 40.0),
            ("Sabine Müller", "Pflegekräfte", "Pflegekraft", "Wirbelsäule", "sabine.mueller@waldkrankenhaus.de", 38.0),
            ("Tina Neumann", "Pflegekräfte", "Pflegekraft", "Wirbelsäule", "tina.neumann@waldkrankenhaus.de", 35.0),
            ("Dr. Daniel Richter", "Ärzte", "Chefarzt", "Wirbelsäule", "daniel.richter@waldkrankenhaus.de", 55.0),
            ("Dr. Erik Sommer", "Ärzte", "Oberarzt", "Wirbelsäule", "erik.sommer@waldkrankenhaus.de", 50.0),
            
            # HNO (12 Betten) - ~3 Pflegekräfte, ~1 Arzt
            ("Ursula Bauer", "Pflegekräfte", "Stationsschwester", "HNO", "ursula.bauer@waldkrankenhaus.de", 40.0),
            ("Vanessa Koch", "Pflegekräfte", "Pflegekraft", "HNO", "vanessa.koch@waldkrankenhaus.de", 35.0),
            ("Wiebke Richter", "Pflegekräfte", "Pflegekraft", "HNO", "wiebke.richter@waldkrankenhaus.de", 40.0),
            ("Dr. Florian Vogt", "Ärzte", "Chefarzt", "HNO", "florian.vogt@waldkrankenhaus.de", 55.0),
            
            # Logistik/Technik (~10 Mitarbeiter)
            ("Hans Meier", "Logistik", "Transport", None, "hans.meier@waldkrankenhaus.de", 40.0),
            ("Jan Schmidt", "Logistik", "Lager", None, "jan.schmidt@waldkrankenhaus.de", 38.0),
            ("Klaus Wagner", "Logistik", "Transport", None, "klaus.wagner@waldkrankenhaus.de", 35.0),
            ("Michael Becker", "Logistik", "Reinigung", None, "michael.becker@waldkrankenhaus.de", 35.0),
            ("Norbert Fischer", "Logistik", "Transport", None, "norbert.fischer@waldkrankenhaus.de", 40.0),
            ("Otto Klein", "Technik", "Medizintechnik", None, "otto.klein@waldkrankenhaus.de", 40.0),
            ("Paul Müller", "Technik", "IT", None, "paul.mueller@waldkrankenhaus.de", 38.0),
            ("Ralf Neumann", "Technik", "Medizintechnik", None, "ralf.neumann@waldkrankenhaus.de", 40.0),
            ("Sebastian Bauer", "Logistik", "Lager", None, "sebastian.bauer@waldkrankenhaus.de", 35.0),
            ("Tim Koch", "Technik", "Wartung", None, "tim.koch@waldkrankenhaus.de", 40.0),
            
            # Verwaltung/Orga (~10 Mitarbeiter)
            ("Anke Adler", "Orga", "Sekretariat", "Verwaltung", "anke.adler@waldkrankenhaus.de", 30.0),
            ("Bettina Berg", "Orga", "Personalwesen", "Verwaltung", "bettina.berg@waldkrankenhaus.de", 35.0),
            ("Claudia Dorn", "Orga", "Sekretariat", "Verwaltung", "claudia.dorn@waldkrankenhaus.de", 30.0),
            ("Diana Eckert", "Orga", "Buchhaltung", "Verwaltung", "diana.eckert@waldkrankenhaus.de", 35.0),
            ("Elisabeth Frank", "Orga", "Sekretariat", "Verwaltung", "elisabeth.frank@waldkrankenhaus.de", 30.0),
            ("Frieda Gross", "Orga", "Personalwesen", "Verwaltung", "frieda.gross@waldkrankenhaus.de", 35.0),
            ("Gisela Huber", "Orga", "Sekretariat", "Verwaltung", "gisela.huber@waldkrankenhaus.de", 30.0),
            ("Heidi Jung", "Orga", "Rechnungswesen", "Verwaltung", "heidi.jung@waldkrankenhaus.de", 35.0),
            ("Ilona Kern", "Orga", "Sekretariat", "Verwaltung", "ilona.kern@waldkrankenhaus.de", 30.0),
            ("Jutta Lindner", "Orga", "Personalwesen", "Verwaltung", "jutta.lindner@waldkrankenhaus.de", 35.0),
        ]
        
        staff_ids = []
        for person in staff_data:
            cursor.execute("""
                INSERT INTO staff (name, category, role, department, contact, contract_hours_per_week)
                VALUES (?, ?, ?, ?, ?, ?)
            """, person)
            staff_ids.append(cursor.lastrowid)
        
        # Dienstpläne für aktuelle und vergangene Wochen generieren
        from datetime import date  # timedelta already imported at module level (line 8)
        
        # Berechne Montag der aktuellen Woche
        today = date.today()
        days_since_monday = today.weekday()
        current_week_monday = today - timedelta(days=days_since_monday)
        
        # Einfacher Algorithmus für Dienstplan-Erstellung
        # Generiere Pläne für 4 Wochen zurück und 2 Wochen voraus
        for week_offset in range(-4, 3):
            week_start = current_week_monday + timedelta(weeks=week_offset)
            week_start_str = week_start.strftime('%Y-%m-%d')
            
            for staff_idx, staff_id in enumerate(staff_ids):
                # Hole Vertragsstunden und Kategorie
                cursor.execute("SELECT contract_hours_per_week, category FROM staff WHERE id = ?", (staff_id,))
                result = cursor.fetchone()
                contract_hours = result[0]
                category = result[1]
                
                # Bestimme Anzahl Arbeitstage basierend auf Vertragsstunden
                if contract_hours >= 40:
                    work_days_count = 5
                    hours_per_day = contract_hours / 5
                elif contract_hours >= 35:
                    work_days_count = random.choice([4, 5])  # 4 oder 5 Tage
                    hours_per_day = contract_hours / work_days_count if work_days_count == 4 else contract_hours / 5
                elif contract_hours >= 30:
                    work_days_count = 4
                    hours_per_day = contract_hours / 4
                else:  # < 30 Stunden
                    work_days_count = 3
                    hours_per_day = contract_hours / 3
                
                hours_per_day = round(hours_per_day, 1)
                
                # Wähle Arbeitstage (vermeide zu viele Tage hintereinander)
                # Strategie: Verteile Tage realistisch über die Woche
                if work_days_count == 5:
                    # 5 Tage: Mo-Fr oder ähnliche Verteilung
                    start_day = random.choice([0, 1])  # Montag oder Dienstag
                    work_days = list(range(start_day, start_day + 5))
                elif work_days_count == 4:
                    # 4 Tage: Wähle 4 Tage mit mindestens einem freien Tag dazwischen
                    patterns = [
                        [0, 1, 3, 4],  # Mo, Di, Do, Fr
                        [0, 2, 3, 5],  # Mo, Mi, Do, Sa
                        [1, 2, 4, 5],  # Di, Mi, Fr, Sa
                    ]
                    work_days = random.choice(patterns)
                else:  # 3 Tage
                    # 3 Tage: Verteile über die Woche
                    patterns = [
                        [0, 2, 4],  # Mo, Mi, Fr
                        [1, 3, 5],  # Di, Do, Sa
                        [0, 3, 5],  # Mo, Do, Sa
                    ]
                    work_days = random.choice(patterns)
                
                # Schichtmuster: Rotiere zwischen Früh-, Spät- und Nachtschicht
                # Verwende staff_idx und week_offset für konsistente Rotation
                shift_pattern_offset = (staff_idx + week_offset) % 3
                
                # Schichtdefinitionen
                shifts = [
                    ("06:00", "14:00", 8.0),   # Frühschicht
                    ("14:00", "22:00", 8.0),   # Spätschicht
                    ("22:00", "06:00", 8.0),   # Nachtschicht
                ]
                
                # Spezielle Behandlung für Ärzte (oft Tagdienst)
                if category == "Ärzte":
                    # Ärzte arbeiten meist Früh- oder Tagschichten (8-16 oder 9-17)
                    if contract_hours >= 50:
                        # Chefarzt/Oberarzt: oft längere Tage
                        shifts = [
                            ("08:00", "16:00", 8.0),
                            ("09:00", "17:00", 8.0),
                            ("08:00", "18:00", 10.0),
                        ]
                    else:
                        # Assistenzärzte: normale Tagesschichten
                        shifts = [
                            ("08:00", "16:00", 8.0),
                            ("09:00", "17:00", 8.0),
                            ("07:00", "15:00", 8.0),
                        ]
                elif category == "Orga":
                    # Verwaltung: nur Tagschichten
                    shifts = [
                        ("08:00", "16:00", 8.0),
                        ("09:00", "17:00", 8.0),
                        ("07:30", "15:30", 8.0),
                    ]
                elif category == "Logistik" or category == "Technik":
                    # Logistik/Technik: frühe Tagschichten
                    shifts = [
                        ("06:00", "14:00", 8.0),
                        ("07:00", "15:00", 8.0),
                        ("08:00", "16:00", 8.0),
                    ]
                
                # Erstelle Dienstplan
                total_planned = 0
                for day_idx, day in enumerate(work_days):
                    # Wähle Schicht basierend auf Rotation
                    shift_idx = (shift_pattern_offset + day_idx) % len(shifts)
                    shift_start, shift_end, shift_hours = shifts[shift_idx]
                    
                    # Für Teilzeit: Passe Stunden an
                    if hours_per_day < shift_hours:
                        # Kürzere Schicht oder Halbtag
                        actual_hours = hours_per_day
                        # Passe Endzeit an
                        start_h, start_m = map(int, shift_start.split(':'))
                        end_time_minutes = start_h * 60 + start_m + int(actual_hours * 60)
                        end_h = (end_time_minutes // 60) % 24
                        end_m = end_time_minutes % 60
                        shift_end = f"{end_h:02d}:{end_m:02d}"
                    elif hours_per_day > shift_hours and hours_per_day <= 10:
                        # Längere Schicht
                        actual_hours = hours_per_day
                        start_h, start_m = map(int, shift_start.split(':'))
                        end_time_minutes = start_h * 60 + start_m + int(actual_hours * 60)
                        end_h = (end_time_minutes // 60) % 24
                        end_m = end_time_minutes % 60
                        shift_end = f"{end_h:02d}:{end_m:02d}"
                    else:
                        actual_hours = shift_hours
                    
                    total_planned += actual_hours
                    
                    cursor.execute("""
                        INSERT INTO schedule_entries (staff_id, week_start_date, day_of_week, planned_hours, shift_start, shift_end)
                        VALUES (?, ?, ?, ?, ?, ?)
                    """, (staff_id, week_start_str, day, actual_hours, shift_start, shift_end))
                
                # Für vergangene Wochen und bereits vergangene Tage der aktuellen Woche: Generiere tatsächliche Stunden
                today = date.today()
                is_past_week = week_offset < 0
                is_current_week = week_offset == 0
                
                if is_past_week or is_current_week:
                    # Hole Abteilung des Mitarbeiters für Ansturm-Wahrscheinlichkeit
                    cursor.execute("SELECT department FROM staff WHERE id = ?", (staff_id,))
                    dept_result = cursor.fetchone()
                    department = dept_result[0] if dept_result else None
                    
                    cursor.execute("""
                        SELECT day_of_week, planned_hours FROM schedule_entries
                        WHERE staff_id = ? AND week_start_date = ?
                    """, (staff_id, week_start_str))
                    schedule_entries = cursor.fetchall()
                    
                    # Bestimme, ob es in dieser Woche einen "Ansturm" gibt
                    # Anstürme kommen häufiger in kritischen Abteilungen vor
                    surge_probability = 0.15  # Basis-Wahrscheinlichkeit 15%
                    if department == "Intensivstation":
                        surge_probability = 0.35  # Intensivstation: 35% Chance
                    elif department == "Chirurgie":
                        surge_probability = 0.30  # Chirurgie: 30% Chance
                    elif department == "Kardiologie":
                        surge_probability = 0.25  # Kardiologie: 25% Chance
                    elif department in ["Orthopädie", "Urologie"]:
                        surge_probability = 0.20  # Orthopädie/Urologie: 20% Chance
                    elif category == "Orga" or category == "Logistik":
                        surge_probability = 0.05  # Verwaltung/Logistik: 5% Chance
                    
                    has_surge_this_week = random.random() < surge_probability
                    
                    # Wenn Ansturm: Bestimme, an welchen Tagen (1-3 Tage in der Woche)
                    surge_days = set()
                    if has_surge_this_week:
                        surge_day_count = random.randint(1, 3)
                        if schedule_entries:
                            available_days = [day for day, _ in schedule_entries]
                            surge_days = set(random.sample(available_days, min(surge_day_count, len(available_days))))
                    
                    for day, planned in schedule_entries:
                        actual_date = week_start + timedelta(days=day)
                        
                        # In der aktuellen Woche: Nur für bereits vergangene Tage tatsächliche Stunden generieren
                        if is_current_week and actual_date > today:
                            continue
                        
                        is_surge_day = day in surge_days
                        
                        if is_surge_day:
                            # Bei Ansturm: Deutlich mehr Überstunden (+2 bis +4 Stunden)
                            # Pflegekräfte und Ärzte haben mehr Überstunden als andere
                            if category == "Pflegekräfte":
                                overtime = random.uniform(2.0, 4.5)
                            elif category == "Ärzte":
                                overtime = random.uniform(1.5, 3.5)
                            else:
                                overtime = random.uniform(1.0, 2.5)
                            actual = planned + overtime
                            notes = "Ansturm/Überstunden"
                        else:
                            # Normale Variation: ± 0-1.5 Stunden
                            variation = random.uniform(-1.5, 1.5)
                            actual = max(0, planned + variation)
                            notes = None
                        
                        cursor.execute("""
                            INSERT INTO actual_hours (staff_id, date, actual_hours, notes)
                            VALUES (?, ?, ?, ?)
                        """, (staff_id, actual_date, round(actual, 1), notes))
        
        conn.commit()
        conn.close()
    
    def get_recent_metrics(self, limit: int = 10) -> List[Dict]:
        """Hole aktuelle Metriken"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM metrics
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_metrics_last_n_minutes(self, minutes: int = 60, metric_type: Optional[str] = None) -> List[Dict]:
        """Hole Metriken der letzten N Minuten"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cutoff_time = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(minutes=minutes)
        
        if metric_type:
            cursor.execute("""
                SELECT * FROM metrics
                WHERE timestamp >= ? AND metric_type = ?
                ORDER BY timestamp ASC
            """, (cutoff_time, metric_type))
        else:
            cursor.execute("""
                SELECT * FROM metrics
                WHERE timestamp >= ?
                ORDER BY timestamp ASC
            """, (cutoff_time,))
        
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_predictions(self, minutes_ahead: int = 15) -> List[Dict]:
        """Hole Vorhersagen für die nächsten N Minuten"""
        conn = self.get_connection()
        cursor = conn.cursor()
        # Filtere auch abgelaufene Vorhersagen heraus (basierend auf timestamp + time_horizon_minutes)
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        cursor.execute("""
            SELECT * FROM predictions
            WHERE time_horizon_minutes <= ?
            AND datetime(timestamp, '+' || time_horizon_minutes || ' minutes') >= ?
            ORDER BY timestamp DESC, time_horizon_minutes ASC
        """, (minutes_ahead, now))
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def generate_realistic_predictions(self, sim_state: Dict, sim_trends: Dict, sim_active_events: List[Dict]) -> List[Dict]:
        """
        Generiere realistische Vorhersagen für alle Abteilungen basierend auf Simulationszustand.
        
        Args:
            sim_state: Aktueller Simulationszustand (ed_load, beds_free, etc.)
            sim_trends: Trends aus Simulation (ed_load trend, etc.)
            sim_active_events: Liste aktiver Surge-Events
        
        Returns:
            Liste von Vorhersagen-Dictionaries
        """
        from utils import calculate_patient_arrival_prediction, calculate_bed_demand_prediction
        
        predictions = []
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        
        # Hole alle Abteilungen aus capacity
        capacity_data = self.get_capacity_overview()
        departments = [c['department'] for c in capacity_data]
        
        # Prüfe ob aktive Surge-Events existieren
        has_active_surge = len(sim_active_events) > 0
        
        # Hole historische Metriken für Patientenzugang
        historical_metrics = self.get_metrics_last_n_minutes(60, 'patient_count')
        
        # Hole Entlassungsplanungsdaten
        discharge_data = self.get_discharge_planning()
        discharge_by_dept = {d['department']: d for d in discharge_data}
        
        # Generiere Vorhersagen für jede Abteilung
        for dept in departments:
            # Hole Kapazitätsdaten für diese Abteilung
            dept_capacity = next((c for c in capacity_data if c['department'] == dept), None)
            if not dept_capacity:
                continue
            
            total_beds = dept_capacity.get('total_beds', 0)
            current_utilization = dept_capacity.get('utilization_rate', 0.0)
            
            # Hole Entlassungsdaten
            discharge_info = discharge_by_dept.get(dept, {})
            ready_for_discharge = discharge_info.get('ready_for_discharge_count', 0)
            
            # Generiere Vorhersagen für 5, 10, 15 Minuten
            for time_horizon in [5, 10, 15]:
                # Patientenzugang-Vorhersage
                ed_load = sim_state.get('ed_load', 65.0)
                trend = sim_trends.get('ed_load', 0.0)
                
                predicted_arrivals, arrival_confidence = calculate_patient_arrival_prediction(
                    ed_load=ed_load,
                    time_horizon_minutes=time_horizon,
                    trend=trend,
                    has_active_surge=has_active_surge,
                    historical_arrivals=historical_metrics
                )
                
                predictions.append({
                    'timestamp': now,
                    'prediction_type': 'patient_arrival',
                    'predicted_value': predicted_arrivals,
                    'confidence': arrival_confidence,
                    'time_horizon_minutes': time_horizon,
                    'department': dept
                })
                
                # Bettenbedarf-Vorhersage
                predicted_utilization, bed_confidence = calculate_bed_demand_prediction(
                    current_utilization=current_utilization,
                    expected_patient_arrivals=predicted_arrivals,
                    time_horizon_minutes=time_horizon,
                    total_beds=total_beds,
                    ready_for_discharge=ready_for_discharge,
                    trend=trend
                )
                
                predictions.append({
                    'timestamp': now,
                    'prediction_type': 'bed_demand',
                    'predicted_value': predicted_utilization,
                    'confidence': bed_confidence,
                    'time_horizon_minutes': time_horizon,
                    'department': dept
                })
        
        return predictions
    
    def update_predictions(self, sim_state: Dict, sim_trends: Dict, sim_active_events: List[Dict]):
        """
        Aktualisiere Vorhersagen: Entferne abgelaufene und generiere neue.
        
        Args:
            sim_state: Aktueller Simulationszustand
            sim_trends: Trends aus Simulation
            sim_active_events: Liste aktiver Surge-Events
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        
        # Entferne abgelaufene Vorhersagen (timestamp + time_horizon_minutes ist in der Vergangenheit)
        cursor.execute("""
            DELETE FROM predictions
            WHERE datetime(timestamp, '+' || time_horizon_minutes || ' minutes') < ?
        """, (now,))
        
        # Generiere neue Vorhersagen
        new_predictions = self.generate_realistic_predictions(sim_state, sim_trends, sim_active_events)
        
        # Füge neue Vorhersagen ein
        for pred in new_predictions:
            cursor.execute("""
                INSERT INTO predictions (timestamp, prediction_type, predicted_value, confidence, time_horizon_minutes, department)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                pred['timestamp'],
                pred['prediction_type'],
                pred['predicted_value'],
                pred['confidence'],
                pred['time_horizon_minutes'],
                pred['department']
            ))
        
        conn.commit()
        conn.close()
    
    def get_active_alerts(self) -> List[Dict]:
        """Hole nicht bestätigte Warnungen"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM alerts
            WHERE resolved = 0
            ORDER BY 
                CASE severity WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                timestamp DESC
        """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_alerts_by_time_range(self, hours: int = 24) -> List[Dict]:
        """Hole Warnungen innerhalb des Zeitraums"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cutoff_time = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(hours=hours)
        cursor.execute("""
            SELECT * FROM alerts
            WHERE timestamp >= ?
            ORDER BY 
                CASE severity WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                timestamp DESC
        """, (cutoff_time,))
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_pending_recommendations(self) -> List[Dict]:
        """Hole ausstehende Empfehlungen"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM recommendations
            WHERE status = 'pending'
            ORDER BY 
                CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                timestamp DESC
        """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_recommendations_by_role(self, role: str = "all") -> List[Dict]:
        """Hole Empfehlungen gefiltert nach Rolle (all, nurse, doctor, manager)"""
        conn = self.get_connection()
        cursor = conn.cursor()
        if role == "all":
            cursor.execute("""
                SELECT * FROM recommendations
                WHERE status = 'pending'
                ORDER BY 
                    CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                    timestamp DESC
            """)
        else:
            # In einer echten App hätten Empfehlungen ein Rollenfeld
            # Für MVP filtern wir nach rec_type oder Abteilung
            cursor.execute("""
                SELECT * FROM recommendations
                WHERE status = 'pending'
                ORDER BY 
                    CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                    timestamp DESC
            """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def accept_recommendation(self, rec_id: int, action_taken: str):
        """Akzeptiere eine Empfehlung"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE recommendations
            SET status = 'accepted',
                action_taken = ?,
                action_timestamp = CURRENT_TIMESTAMP
            WHERE id = ?
        """, (action_taken, rec_id))
        conn.commit()
        # Randomize role for demo purposes
        roles = ['nurse', 'doctor', 'admin', 'manager']
        role = random.choice(roles)
        self.log_audit("recommendation_accepted", role, "recommendation", rec_id, f"Action: {action_taken}")
        conn.close()
    
    def reject_recommendation(self, rec_id: int, reason: str):
        """Lehne eine Empfehlung ab"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE recommendations
            SET status = 'rejected',
                action_taken = ?,
                action_timestamp = CURRENT_TIMESTAMP
            WHERE id = ?
        """, (reason, rec_id))
        conn.commit()
        # Randomize role for demo purposes
        roles = ['nurse', 'doctor', 'admin', 'manager']
        role = random.choice(roles)
        self.log_audit("recommendation_rejected", role, "recommendation", rec_id, f"Reason: {reason}")
        conn.close()
    
    def acknowledge_alert(self, alert_id: int):
        """Bestätige eine Warnung"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE alerts
            SET acknowledged = 1
            WHERE id = ?
        """, (alert_id,))
        conn.commit()
        # Randomize role for demo purposes
        roles = ['nurse', 'doctor', 'admin', 'manager']
        role = random.choice(roles)
        self.log_audit("alert_acknowledged", role, "alert", alert_id, "")
        conn.close()
    
    def _alert_exists(self, alert_type: str, message: str, department: Optional[str] = None, 
                     severity: Optional[str] = None, hours: int = 2) -> bool:
        """Prüfe ob eine ähnliche Alert bereits existiert (innerhalb der letzten N Stunden)"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cutoff_time = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(hours=hours)
        
        query = """
            SELECT COUNT(*) FROM alerts
            WHERE alert_type = ? AND message = ? AND resolved = 0
            AND timestamp >= ?
        """
        params = [alert_type, message, cutoff_time]
        
        if department:
            query += " AND department = ?"
            params.append(department)
        
        cursor.execute(query, params)
        count = cursor.fetchone()[0]
        conn.close()
        return count > 0
    
    def _normalize_severity(self, severity: str) -> str:
        """Normalisiere Severity-Werte (Deutsch -> Englisch)"""
        severity_map = {
            'hoch': 'high',
            'mittel': 'medium',
            'niedrig': 'low',
            'kritisch': 'high',
            'high': 'high',
            'medium': 'medium',
            'low': 'low'
        }
        return severity_map.get(severity.lower(), 'medium')
    
    def _create_alert(self, alert_type: str, severity: str, message: str, 
                     department: Optional[str] = None):
        """Erstelle eine Alert in der Datenbank, wenn sie noch nicht existiert"""
        # Normalisiere Severity zu englischen Werten
        normalized_severity = self._normalize_severity(severity)
        
        if not self._alert_exists(alert_type, message, department, normalized_severity):
            conn = self.get_connection()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO alerts (timestamp, alert_type, severity, message, department, acknowledged, resolved)
                VALUES (?, ?, ?, ?, ?, 0, 0)
            """, (datetime.now(timezone.utc).replace(tzinfo=None), alert_type, normalized_severity, message, department))
            conn.commit()
            conn.close()
    
    def generate_alerts(self, sim_metrics: Optional[Dict] = None, sim_trends: Optional[Dict] = None):
        """
        Generiere Warnungen basierend auf aktuellen Daten aus allen Tabs.
        
        Args:
            sim_metrics: Aktuelle Simulationsmetriken (optional)
            sim_trends: Trends aus Simulation (optional)
        """
        from utils import (
            calculate_capacity_status, calculate_inventory_status,
            get_metric_severity_for_load, get_metric_severity_for_count, 
            get_metric_severity_for_free
        )
        
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        
        # 1. Kapazitätsstatus überwachen
        capacity = self.get_capacity_from_simulation(sim_metrics) if sim_metrics else self.get_capacity_overview()
        for cap in capacity:
            status = calculate_capacity_status(cap['utilization_rate'])
            dept = cap.get('department', 'N/A')
            
            if status['status'] == 'kritisch':
                self._create_alert(
                    'capacity',
                    'high',
                    f"{dept}-Kapazität bei {status['percentage']}%",
                    dept
                )
            elif status['status'] == 'hoch' and status['percentage'] >= 85:
                self._create_alert(
                    'capacity',
                    'medium',
                    f"{dept}-Kapazität bei {status['percentage']}%",
                    dept
                )
        
        # 2. Inventarstatus überwachen
        inventory = self.get_inventory_status()
        for item in inventory:
            status = calculate_inventory_status(
                item['current_stock'], 
                item['min_threshold'], 
                item['max_capacity']
            )
            dept = item.get('department', 'N/A')
            
            if status['is_critical']:
                self._create_alert(
                    'inventory',
                    'high',
                    f"{item['item_name']} kritisch niedrig: {item['current_stock']} {item['unit']}",
                    dept
                )
            elif status['is_low']:
                self._create_alert(
                    'inventory',
                    'medium',
                    f"{item['item_name']} unter Mindestbestand: {item['current_stock']} {item['unit']}",
                    dept
                )
        
        # 3. Gerätewartungs-Dringlichkeiten überwachen
        devices = self.get_device_maintenance_urgencies()
        for device in devices:
            urgency_level = device.get('urgency_level', '').lower()
            dept = device.get('department', 'N/A')
            device_id = device.get('device_id', 'N/A')
            device_type = device.get('device_type', 'Gerät')
            
            # Berechne Tage bis Wartung
            days_until_due = None
            if device.get('next_maintenance_due'):
                try:
                    if isinstance(device['next_maintenance_due'], str):
                        next_due = datetime.strptime(device['next_maintenance_due'], '%Y-%m-%d')
                    else:
                        next_due = device['next_maintenance_due']
                    days_until_due = (next_due - now).days
                except:
                    pass
            
            if urgency_level in ['high', 'hoch']:
                days_text = f" ({days_until_due} Tage)" if days_until_due is not None else ""
                if days_until_due is not None and days_until_due < 0:
                    self._create_alert(
                        'device',
                        'high',
                        f"{device_type} #{device_id} wartungsüberfällig{days_text}",
                        dept
                    )
                else:
                    self._create_alert(
                        'device',
                        'high',
                        f"{device_type} #{device_id} benötigt dringend Wartung{days_text}",
                        dept
                    )
            elif urgency_level in ['medium', 'mittel'] and days_until_due is not None and days_until_due <= 7:
                self._create_alert(
                    'device',
                    'medium',
                    f"{device_type} #{device_id} benötigt Wartung in {days_until_due} Tagen",
                    dept
                )
        
        # 4. Dashboard-Metriken überwachen (wenn sim_metrics verfügbar)
        if sim_metrics:
            # ED Load
            ed_load = sim_metrics.get('ed_load', 0)
            ed_severity, _ = get_metric_severity_for_load(ed_load)
            if ed_severity in ['high', 'hoch']:
                self._create_alert(
                    'capacity',
                    ed_severity,
                    f"Notaufnahme-Auslastung bei {ed_load:.0f}%",
                    'ER'
                )
            
            # Waiting Count
            waiting_count = int(sim_metrics.get('waiting_count', 0))
            waiting_severity, _ = get_metric_severity_for_count(waiting_count, {'critical': 20, 'watch': 10})
            if waiting_severity in ['high', 'hoch']:
                self._create_alert(
                    'patient',
                    waiting_severity,
                    f"{waiting_count} Patienten warten in der Notaufnahme",
                    'ER'
                )
            
            # Beds Free
            beds_free = int(sim_metrics.get('beds_free', 0))
            total_beds = sum([c['total_beds'] for c in capacity]) if capacity else 100
            beds_severity, _ = get_metric_severity_for_free(beds_free, total_beds)
            if beds_severity in ['high', 'hoch']:
                self._create_alert(
                    'capacity',
                    beds_severity,
                    f"Nur noch {beds_free} freie Betten verfügbar",
                    None
                )
            
            # Staff Load
            staff_load = sim_metrics.get('staff_load', 0)
            staff_severity, _ = get_metric_severity_for_load(staff_load)
            if staff_severity in ['high', 'hoch']:
                self._create_alert(
                    'staffing',
                    staff_severity,
                    f"Personal-Auslastung bei {staff_load:.0f}%",
                    None
                )
            
            # Transport Queue
            transport_queue = int(sim_metrics.get('transport_queue', 0))
            transport_severity, _ = get_metric_severity_for_count(transport_queue, {'critical': 8, 'watch': 5})
            if transport_severity in ['high', 'hoch']:
                self._create_alert(
                    'transport',
                    transport_severity,
                    f"{transport_queue} Transporte in der Warteschlange",
                    None
                )
        
        # 5. Transportanfragen überwachen
        transport_requests = self.get_transport_requests()
        pending_transports = [t for t in transport_requests if t['status'] in ['pending', 'ausstehend']]
        if len(pending_transports) >= 5:
            self._create_alert(
                'transport',
                'medium',
                f"{len(pending_transports)} ausstehende Transportanfragen",
                None
            )
        
        # 6. Vorhersagen überwachen (kritische Werte vorhergesagt)
        predictions = self.get_predictions(15)
        for pred in predictions:
            pred_type = pred.get('prediction_type', '')
            pred_value = pred.get('predicted_value', 0)
            dept = pred.get('department', 'N/A')
            
            if pred_type == 'bed_demand' and pred_value >= 90:
                self._create_alert(
                    'capacity',
                    'medium',
                    f"Vorhersage: {dept}-Bettenbedarf bei {pred_value:.0f}% in {pred.get('time_horizon_minutes', 0)} Min.",
                    dept
                )
            elif pred_type == 'patient_arrival' and pred_value >= 10:
                self._create_alert(
                    'patient',
                    'medium',
                    f"Vorhersage: {pred_value:.0f} Patientenzugänge in {pred.get('time_horizon_minutes', 0)} Min. erwartet",
                    dept
                )
        
        # 7. Trend-Überwachung (schnelle Anstiege)
        if sim_trends and sim_metrics:
            ed_trend = sim_trends.get('ed_load', 0)
            if ed_trend > 0.5 and sim_metrics.get('ed_load', 0) > 70:
                self._create_alert(
                    'capacity',
                    'medium',
                    f"Schneller Anstieg der Notaufnahme-Auslastung erkannt",
                    'ER'
                )
        
        # 8. Korrelations-Überwachung (mehrere Metriken gleichzeitig kritisch)
        if sim_metrics:
            critical_count = 0
            ed_load = sim_metrics.get('ed_load', 0)
            beds_free = int(sim_metrics.get('beds_free', 0))
            staff_load = sim_metrics.get('staff_load', 0)
            waiting_count = int(sim_metrics.get('waiting_count', 0))
            
            if ed_load >= 85:
                critical_count += 1
            if beds_free <= 5:
                critical_count += 1
            if staff_load >= 85:
                critical_count += 1
            if waiting_count >= 15:
                critical_count += 1
            
            if critical_count >= 3:
                self._create_alert(
                    'general',
                    'high',
                    f"Mehrere kritische Metriken gleichzeitig aktiv ({critical_count} Bereiche)",
                    None
                )
    
    def get_transport_requests(self, status: Optional[str] = None) -> List[Dict]:
        """Hole Transportanfragen"""
        conn = self.get_connection()
        cursor = conn.cursor()
        if status:
            cursor.execute("""
                SELECT * FROM transport
                WHERE status = ?
                ORDER BY 
                    CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                    timestamp DESC
            """, (status,))
        else:
            cursor.execute("""
                SELECT * FROM transport
                ORDER BY 
                    CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                    timestamp DESC
            """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def create_inventory_order(self, item_id: int, quantity: int, department: Optional[str] = None) -> Dict:
        """Erstellt eine Inventar-Bestellung und zugehörige Transportanfrage"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        # Hole Item-Details
        cursor.execute("SELECT item_name, department FROM inventory WHERE id = ?", (item_id,))
        item_result = cursor.fetchone()
        if not item_result:
            conn.close()
            raise ValueError(f"Item mit ID {item_id} nicht gefunden")
        
        item_name, item_dept = item_result
        dept = department or item_dept
        
        # Erstelle Bestellung
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        cursor.execute("""
            INSERT INTO inventory_orders (timestamp, item_id, item_name, quantity, department, status)
            VALUES (?, ?, ?, ?, ?, 'ordered')
        """, (now, item_id, item_name, quantity, dept))
        order_id = cursor.lastrowid
        
        # Bestimme Priorität basierend auf aktuellen Bestand
        cursor.execute("SELECT current_stock, min_threshold FROM inventory WHERE id = ?", (item_id,))
        stock_result = cursor.fetchone()
        if stock_result:
            current_stock, min_threshold = stock_result
            if current_stock < min_threshold:
                priority = 'high'
            elif current_stock < min_threshold * 1.5:
                priority = 'medium'
            else:
                priority = 'low'
        else:
            priority = 'medium'
        
        # Erstelle Transportanfrage (von Lager zu Abteilung)
        from_location = "Lager"
        to_location = dept or "Zentrallager"
        
        # Geschätzte Zeit: 10-30 Minuten für Inventar-Transporte
        estimated_time = random.randint(10, 30)
        
        # Geplante Startzeit: 5-30 Minuten in der Zukunft
        planned_start_time = now + timedelta(minutes=random.randint(5, 30))
        
        cursor.execute("""
            INSERT INTO transport (timestamp, request_type, from_location, to_location, priority, status, 
                                 estimated_time_minutes, related_entity_type, related_entity_id, planned_start_time)
            VALUES (?, 'equipment', ?, ?, ?, 'pending', ?, 'inventory_order', ?, ?)
        """, (now, from_location, to_location, priority, estimated_time, order_id, planned_start_time))
        transport_id = cursor.lastrowid
        
        # Verknüpfe Bestellung mit Transport
        cursor.execute("""
            UPDATE inventory_orders SET transport_id = ? WHERE id = ?
        """, (transport_id, order_id))
        
        conn.commit()
        conn.close()
        
        return {
            'order_id': order_id,
            'transport_id': transport_id,
            'item_name': item_name,
            'quantity': quantity,
            'department': dept,
            'status': 'ordered'
        }
    
    def create_patient_transport(self, from_location: str, to_location: str, priority: str = 'medium') -> int:
        """Erstellt eine Transportanfrage für Patiententransfer"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        
        # Geschätzte Zeit: 5-15 Minuten für Patiententransporte
        estimated_time = random.randint(5, 15)
        
        # Geplante Startzeit: 0-15 Minuten in der Zukunft
        planned_start_time = now + timedelta(minutes=random.randint(0, 15))
        
        cursor.execute("""
            INSERT INTO transport (timestamp, request_type, from_location, to_location, priority, status,
                                 estimated_time_minutes, related_entity_type, planned_start_time)
            VALUES (?, 'patient', ?, ?, ?, 'pending', ?, 'patient_transfer', ?)
        """, (now, from_location, to_location, priority, estimated_time, planned_start_time))
        transport_id = cursor.lastrowid
        
        conn.commit()
        conn.close()
        
        return transport_id
    
    def update_transport_status(self, transport_id: int, status: str, actual_time_minutes: Optional[int] = None,
                                start_time: Optional[datetime] = None, 
                                expected_completion_time: Optional[datetime] = None,
                                delay_minutes: Optional[int] = None):
        """Aktualisiert Transport-Status"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        updates = []
        params = []
        
        if status:
            updates.append("status = ?")
            params.append(status)
        if actual_time_minutes is not None:
            updates.append("actual_time_minutes = ?")
            params.append(actual_time_minutes)
        if start_time:
            updates.append("start_time = ?")
            params.append(start_time.replace(tzinfo=None) if start_time.tzinfo else start_time)
        if expected_completion_time:
            updates.append("expected_completion_time = ?")
            params.append(expected_completion_time.replace(tzinfo=None) if expected_completion_time.tzinfo else expected_completion_time)
        if delay_minutes is not None:
            updates.append("delay_minutes = ?")
            params.append(delay_minutes)
        
        if updates:
            params.append(transport_id)
            cursor.execute(f"""
                UPDATE transport
                SET {', '.join(updates)}
                WHERE id = ?
            """, params)
            conn.commit()
        
        conn.close()
    
    def complete_inventory_transport(self, transport_id: int):
        """Markiert Inventar-Transport als abgeschlossen und erhöht Inventar-Bestand"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        # Hole Transport-Details
        cursor.execute("""
            SELECT related_entity_id, actual_time_minutes FROM transport WHERE id = ?
        """, (transport_id,))
        transport_result = cursor.fetchone()
        
        if not transport_result:
            conn.close()
            return
        
        order_id, actual_time = transport_result
        
        # Hole Bestellungs-Details
        cursor.execute("""
            SELECT item_id, quantity FROM inventory_orders WHERE id = ?
        """, (order_id,))
        order_result = cursor.fetchone()
        
        if not order_result:
            conn.close()
            return
        
        item_id, quantity = order_result
        
        # Erhöhe Inventar-Bestand
        cursor.execute("""
            SELECT current_stock, max_capacity FROM inventory WHERE id = ?
        """, (item_id,))
        stock_result = cursor.fetchone()
        
        if stock_result:
            current_stock, max_capacity = stock_result
            new_stock = min(current_stock + quantity, max_capacity)
            
            cursor.execute("""
                UPDATE inventory
                SET current_stock = ?, timestamp = CURRENT_TIMESTAMP
                WHERE id = ?
            """, (new_stock, item_id))
            
            # Aktualisiere Bestellungs-Status
            cursor.execute("""
                UPDATE inventory_orders
                SET status = 'delivered'
                WHERE id = ?
            """, (order_id,))
        
        conn.commit()
        conn.close()
    
    def get_pending_transports(self) -> List[Dict]:
        """Holt ausstehende Transporte für Verarbeitung"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM transport
            WHERE status IN ('pending', 'in_progress', 'in_bearbeitung')
            ORDER BY 
                CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
                timestamp ASC
        """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_inventory_orders(self, status: Optional[str] = None) -> List[Dict]:
        """Holt Inventar-Bestellungen"""
        conn = self.get_connection()
        cursor = conn.cursor()
        if status:
            cursor.execute("""
                SELECT * FROM inventory_orders
                WHERE status = ?
                ORDER BY timestamp DESC
            """, (status,))
        else:
            cursor.execute("""
                SELECT * FROM inventory_orders
                ORDER BY timestamp DESC
            """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_inventory_status(self) -> List[Dict]:
        """Hole Inventarstatus"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM inventory
            ORDER BY 
                CASE WHEN current_stock < min_threshold THEN 1 ELSE 2 END,
                department, item_name
        """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_inventory_consumption_history(self, item_id: Optional[int] = None, item_name: Optional[str] = None, days: int = 30) -> List[Dict]:
        """Hole Verbrauchshistorie für einen Artikel oder alle Artikel"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cutoff_time = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(days=days)
        
        if item_id:
            cursor.execute("""
                SELECT * FROM inventory_consumption
                WHERE item_id = ? AND timestamp >= ?
                ORDER BY timestamp ASC
            """, (item_id, cutoff_time))
        elif item_name:
            cursor.execute("""
                SELECT * FROM inventory_consumption
                WHERE item_name = ? AND timestamp >= ?
                ORDER BY timestamp ASC
            """, (item_name, cutoff_time))
        else:
            cursor.execute("""
                SELECT * FROM inventory_consumption
                WHERE timestamp >= ?
                ORDER BY timestamp ASC
            """, (cutoff_time,))
        
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def calculate_inventory_consumption_rate(self, item_id: int, sim_state: Optional[Dict] = None) -> Dict:
        """
        Berechne Verbrauchsrate für einen Artikel basierend auf Historie und aktueller Aktivität.
        
        Returns:
            Dict mit 'daily_rate', 'historical_rate', 'activity_rate', 'combined_rate'
        """
        from utils import calculate_daily_consumption_from_activity
        
        # Hole Verbrauchshistorie (letzte 30 Tage)
        history = self.get_inventory_consumption_history(item_id=item_id, days=30)
        
        # Berechne historische Verbrauchsrate
        historical_rate = 0.0
        if history:
            # Gruppiere nach Tagen und berechne Durchschnitt
            daily_consumption = {}
            for entry in history:
                # Extrahiere Datum (ohne Zeit)
                if isinstance(entry['timestamp'], str):
                    date_key = entry['timestamp'][:10]
                else:
                    date_key = entry['timestamp'].date().isoformat()
                
                if date_key not in daily_consumption:
                    daily_consumption[date_key] = []
                # consumption_amount ist bereits täglicher Verbrauch (geschätzt)
                daily_consumption[date_key].append(entry['consumption_amount'])
            
            # Berechne durchschnittlichen täglichen Verbrauch
            # Da wir mehrere Einträge pro Tag haben können (alle 5-10 Minuten),
            # nehmen wir den Durchschnitt der Einträge pro Tag
            daily_totals = []
            for date_key, consumption_values in daily_consumption.items():
                # Durchschnitt der Verbrauchswerte für diesen Tag
                avg_daily = sum(consumption_values) / len(consumption_values)
                daily_totals.append(avg_daily)
            
            if daily_totals:
                # Durchschnitt über alle Tage
                historical_rate = sum(daily_totals) / len(daily_totals)
        
        # Berechne Verbrauch basierend auf aktueller Aktivität
        activity_rate = 0.0
        if sim_state:
            # Hole Artikel-Info
            inventory = self.get_inventory_status()
            item = next((i for i in inventory if i['id'] == item_id), None)
            if item:
                activity_rate = calculate_daily_consumption_from_activity(
                    item=item,
                    ed_load=sim_state.get('ed_load', 65.0),
                    beds_occupied=sim_state.get('beds_occupied', 0),
                    capacity_data=self.get_capacity_overview()
                )
        
        # Kombinierte Rate: 60% Historie, 40% Aktivität (wenn beide verfügbar)
        if historical_rate > 0 and activity_rate > 0:
            combined_rate = (historical_rate * 0.6) + (activity_rate * 0.4)
        elif historical_rate > 0:
            combined_rate = historical_rate
        elif activity_rate > 0:
            combined_rate = activity_rate
        else:
            # Fallback: Schätze basierend auf Mindestbestand
            inventory = self.get_inventory_status()
            item = next((i for i in inventory if i['id'] == item_id), None)
            if item:
                combined_rate = max(item['min_threshold'] * 0.1, 1.0)
            else:
                combined_rate = 1.0
        
        return {
            'daily_rate': combined_rate,
            'historical_rate': historical_rate,
            'activity_rate': activity_rate,
            'combined_rate': combined_rate
        }
    
    def record_inventory_consumption(self, item_id: int, item_name: str, consumption_amount: float, 
                                     department: Optional[str] = None, ed_load: Optional[float] = None,
                                     beds_occupied: Optional[int] = None, activity_factor: Optional[float] = None):
        """Speichere Verbrauchseintrag"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO inventory_consumption 
            (item_id, item_name, consumption_amount, department, ed_load, beds_occupied, hospital_activity_factor)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (item_id, item_name, consumption_amount, department, ed_load, beds_occupied, activity_factor))
        conn.commit()
        conn.close()
    
    def get_device_maintenance_urgencies(self) -> List[Dict]:
        """Hole Gerätewartungs-Dringlichkeiten"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM device_maintenance
            ORDER BY 
                CASE urgency_level WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 
                WHEN 'hoch' THEN 1 WHEN 'mittel' THEN 2 WHEN 'niedrig' THEN 3 END,
                next_maintenance_due ASC
        """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_discharge_planning(self) -> List[Dict]:
        """Hole aggregierte Entlassungsplanungsdaten"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM discharge_planning
            ORDER BY department
        """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_capacity_overview(self) -> List[Dict]:
        """Hole Kapazitätsübersicht"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM capacity
            ORDER BY utilization_rate DESC, department
        """)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_capacity_from_simulation(self, sim_metrics: Dict) -> List[Dict]:
        """Berechne Kapazitätsdaten aus Simulationszustand, kombiniert mit DB-Gesamtkapazität
        
        Args:
            sim_metrics: Dictionary mit Simulationsmetriken (z.B. von sim.get_current_metrics())
        
        Returns:
            Liste von Kapazitätsdaten, konsistent mit Simulationsdaten
        """
        # Hole DB-Kapazitätsdaten für total_beds pro Abteilung
        db_capacity = self.get_capacity_overview()
        
        if not db_capacity:
            return []
        
        # Gesamtbetten aus DB
        total_beds_db = sum([c['total_beds'] for c in db_capacity])
        
        # Freie Betten aus Simulation (gesamt) - sicherstellen, dass es nicht größer als total_beds_db ist
        beds_free_sim = max(0, min(int(sim_metrics.get('beds_free', 0)), total_beds_db))
        
        # Verteile freie Betten proportional auf Abteilungen basierend auf total_beds
        capacity_result = []
        beds_free_remaining = beds_free_sim
        
        for i, cap in enumerate(db_capacity):
            dept_total = cap['total_beds']
            
            if i == len(db_capacity) - 1:
                # Letzte Abteilung: verwende verbleibende freie Betten (sicherstellen, dass Summe korrekt ist)
                dept_available = beds_free_remaining
            else:
                # Anteilige Verteilung basierend auf Gesamtkapazität
                dept_ratio = dept_total / total_beds_db if total_beds_db > 0 else 0
                dept_available = int(beds_free_sim * dept_ratio)
                beds_free_remaining -= dept_available
            
            # Sicherstellen, dass verfügbare Betten innerhalb der Grenzen sind
            dept_available = max(0, min(dept_total, dept_available))
            dept_occupied = dept_total - dept_available
            dept_utilization = dept_occupied / dept_total if dept_total > 0 else 0.0
            
            # Räume-Daten aus DB übernehmen oder berechnen
            total_rooms = cap.get('total_rooms', 0)
            available_rooms = cap.get('available_rooms', 0)
            # Falls nicht in DB, schätze basierend auf Betten
            if total_rooms == 0 or total_rooms is None:
                total_rooms = max(5, int(dept_total * 0.4))
            if available_rooms is None:
                available_rooms = max(0, int(dept_available * 0.4))
            
            capacity_result.append({
                'id': cap['id'],
                'timestamp': cap['timestamp'],
                'department': cap['department'],
                'total_beds': dept_total,
                'occupied_beds': dept_occupied,
                'available_beds': dept_available,
                'utilization_rate': dept_utilization,
                'total_rooms': total_rooms,
                'available_rooms': available_rooms
            })
        
        return capacity_result
    
    def get_total_rooms(self) -> int:
        """Hole Gesamtzahl der Räume aus allen Abteilungen"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT COALESCE(SUM(total_rooms), 0) as total
            FROM capacity
            WHERE total_rooms IS NOT NULL
        """)
        result = cursor.fetchone()
        conn.close()
        if result and result[0] is not None:
            return int(result[0])
        # Fallback: Berechne aus Betten wenn keine Räume-Daten vorhanden
        capacity = self.get_capacity_overview()
        total_beds = sum([c.get('total_beds', 0) for c in capacity])
        return max(45, int(total_beds * 0.4))  # ~40% der Betten als Räume
    
    def get_audit_log(self, limit: int = 50) -> List[Dict]:
        """Hole Prüfprotokoll"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM audit_log
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def log_audit(self, action_type: str, user_role: str, entity_type: str, entity_id: int, details: str):
        """Protokolliere ein Prüfereignis"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO audit_log (action_type, user_role, entity_type, entity_id, details, ip_address)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (action_type, user_role, entity_type, entity_id, details, "127.0.0.1"))
        conn.commit()
        conn.close()
    
    def get_all_staff(self) -> Dict[str, List[Dict]]:
        """Hole alle Mitarbeiter gruppiert nach Kategorie, dann alphabetisch sortiert"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM staff
            ORDER BY category, name
        """)
        rows = cursor.fetchall()
        conn.close()
        
        staff_list = [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
        
        # Gruppiere nach Kategorie
        grouped = {}
        for person in staff_list:
            category = person['category']
            if category not in grouped:
                grouped[category] = []
            grouped[category].append(person)
        
        return grouped
    
    def get_staff_by_category(self, category: str) -> List[Dict]:
        """Hole Mitarbeiter nach Kategorie, alphabetisch sortiert"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM staff
            WHERE category = ?
            ORDER BY name
        """, (category,))
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_staff_schedule(self, staff_id: int, week_start_date: str) -> List[Dict]:
        """Hole Wochenplan für eine Person (Montag-Sonntag)"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM schedule_entries
            WHERE staff_id = ? AND week_start_date = ?
            ORDER BY day_of_week
        """, (staff_id, week_start_date))
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_actual_hours(self, staff_id: int, week_start_date: str) -> List[Dict]:
        """Hole tatsächliche Stunden für eine Woche"""
        from datetime import datetime, timedelta
        
        # Berechne Datumsbereich der Woche (Montag bis Sonntag)
        week_start = datetime.strptime(week_start_date, '%Y-%m-%d').date()
        week_end = week_start + timedelta(days=6)
        
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM actual_hours
            WHERE staff_id = ? AND date >= ? AND date <= ?
            ORDER BY date
        """, (staff_id, week_start, week_end))
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def record_operation(self, operation_type: str, department: str, status: str, 
                        duration_minutes: Optional[int] = None, 
                        start_time: Optional[datetime] = None,
                        end_time: Optional[datetime] = None,
                        planned_start_time: Optional[datetime] = None) -> int:
        """Speichere eine neue Operation in der Datenbank"""
        conn = self.get_connection()
        cursor = conn.cursor()
        now = datetime.now(timezone.utc).replace(tzinfo=None)
        
        cursor.execute("""
            INSERT INTO operations (timestamp, operation_type, department, status, 
                                  duration_minutes, start_time, end_time, planned_start_time)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (now, operation_type, department, status, duration_minutes, start_time, end_time, planned_start_time))
        
        operation_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return operation_id
    
    def get_recent_operations(self, hours: int = 24, status: Optional[str] = None, 
                              department: Optional[str] = None) -> List[Dict]:
        """Hole aktuelle/abgeschlossene Operationen"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cutoff_time = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(hours=hours)
        
        query = """
            SELECT * FROM operations
            WHERE timestamp >= ?
        """
        params = [cutoff_time]
        
        if status:
            query += " AND status = ?"
            params.append(status)
        
        if department:
            query += " AND department = ?"
            params.append(department)
        
        query += " ORDER BY timestamp DESC"
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        conn.close()
        return [dict(zip([col[0] for col in cursor.description], row)) for row in rows]
    
    def get_operations_consumption(self, hours: int = 24) -> Dict[str, int]:
        """Hole Anzahl abgeschlossener Operationen pro Abteilung"""
        conn = self.get_connection()
        cursor = conn.cursor()
        cutoff_time = datetime.now(timezone.utc).replace(tzinfo=None) - timedelta(hours=hours)
        
        cursor.execute("""
            SELECT department, COUNT(*) as count
            FROM operations
            WHERE status = 'abgeschlossen' AND timestamp >= ?
            GROUP BY department
        """, (cutoff_time,))
        
        rows = cursor.fetchall()
        conn.close()
        
        result = {}
        for row in rows:
            result[row[0]] = row[1]
        
        return result
    
    def update_inventory_from_operation(self, operation_type: str, department: str, 
                                       consumption_map: Dict[str, float]):
        """
        Reduziere Bestand basierend auf Operation.
        
        Args:
            operation_type: Typ der Operation
            department: Abteilung
            consumption_map: Dict mit item_name -> consumption_amount
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        
        for item_name, consumption_amount in consumption_map.items():
            # Hole aktuellen Bestand für dieses Material in dieser Abteilung
            cursor.execute("""
                SELECT id, current_stock FROM inventory
                WHERE item_name = ? AND department = ?
                ORDER BY id DESC LIMIT 1
            """, (item_name, department))
            
            result = cursor.fetchone()
            if result:
                item_id, current_stock = result
                new_stock = max(0, int(current_stock - consumption_amount))
                
                # Aktualisiere Bestand
                cursor.execute("""
                    UPDATE inventory
                    SET current_stock = ?, timestamp = CURRENT_TIMESTAMP
                    WHERE id = ?
                """, (new_stock, item_id))
                
                # Protokolliere Verbrauch
                now = datetime.now(timezone.utc).replace(tzinfo=None)
                cursor.execute("""
                    INSERT INTO inventory_consumption 
                    (item_id, item_name, consumption_amount, department, ed_load, beds_occupied, hospital_activity_factor)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (item_id, item_name, consumption_amount, department, None, None, None))
        
        conn.commit()
        conn.close()
    
    def calculate_overtime(self, staff_id: int, week_start_date: str) -> Dict:
        """Berechne Überstunden für eine Woche basierend auf Vertrag"""
        from datetime import datetime, timedelta
        
        # Hole Personendaten
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT contract_hours_per_week FROM staff WHERE id = ?", (staff_id,))
        result = cursor.fetchone()
        if not result:
            conn.close()
            return {'contract_hours': 0, 'planned_hours': 0, 'actual_hours': 0, 'overtime': 0}
        
        contract_hours = result[0]
        conn.close()
        
        # Berechne geplante Stunden
        schedule = self.get_staff_schedule(staff_id, week_start_date)
        planned_hours = sum([entry['planned_hours'] for entry in schedule])
        
        # Berechne tatsächliche Stunden
        actual_entries = self.get_actual_hours(staff_id, week_start_date)
        actual_hours = sum([entry['actual_hours'] for entry in actual_entries])
        
        # Überstunden = tatsächliche Stunden - Vertragsstunden
        overtime = actual_hours - contract_hours if actual_hours > 0 else 0
        
        return {
            'contract_hours': contract_hours,
            'planned_hours': planned_hours,
            'actual_hours': actual_hours,
            'overtime': overtime
        }

